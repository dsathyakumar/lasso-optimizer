'use strict';

const { parse } = require('@babel/parser');
const generate = require('@babel/generator');
const { grabInfoFromAst } = require('./ast-walker-scanner');
const { resolvePaths } = require('./paths-resolver');
const { walkAstAndReplace } = require('./ast-walker-replacer');
const { injectClient } = require('./lasso-modules-client-shim');
const { version } = require('../package.json');
const { propGenerator } = require('./generator');

const init = (code, noConflictLassoVar) => {
    const generator = propGenerator(2);

    if (!code) {
        return;
    }

    if (typeof code !== 'string') {
        return;
    }

    let output = null;
    let pathInfo = null;

    try {
        const ast = parse(code, {
            sourceType: 'script'
        });

        pathInfo = grabInfoFromAst(ast, noConflictLassoVar, undefined, generator);

        const { dependencyPathToVarName, meta } = resolvePaths(pathInfo);

        const modifiedAst = walkAstAndReplace(
            ast,
            dependencyPathToVarName,
            pathInfo.variableName,
            meta
        );

        output = generate.default(modifiedAst, {
            sourceMaps: true,
            auxiliaryCommentBefore: `Generated by lasso-optimizer@${version}`
        });
    } catch (e) {
        console.error(e.message);
        console.error(`Resetting output to undefined so that default code is returned`);
        output = undefined;
    }

    return {
        output,
        lassoVariableName: pathInfo.variableName
    };
};

exports.optimizeSingle = (code, noConflictLassoVar, shouldInjectClient = true) => {
    const {
        output,
        // eslint-disable-next-line prefer-const
        lassoVariableName
    } = init(code, noConflictLassoVar);

    if (typeof output === 'undefined') {
        console.error(`Lasso-optimizer errored out. Returing code as-is`);
        return code;
    }

    if (typeof output !== 'object' || !('code' in output)) {
        console.error(`Lasso-optimizer errored out. Returing code as-is`);
        return code;
    }

    if (shouldInjectClient && output.code) {
        output.code = injectClient(output.code, (noConflictLassoVar || lassoVariableName));
    }

    return output;
};
